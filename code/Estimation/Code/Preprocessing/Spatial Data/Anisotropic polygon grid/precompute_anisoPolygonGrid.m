function [ SpatData, ...
           typeKernel ] = precompute_anisoPolygonGrid( SpatData, ...
                                                       Catalog, ...
                                                       poly, ...
                                                       spaceUnit, ...
                                                       makeChecks, ...
                                                       makePlots )
%
% If modelDesign is chosen to be anisotropic, this function precomputes all information necessary
% for computing the spatial integrals of anisotropic triggering distributions in later ETAS 
% iteration steps and stores them in cell arrays.
%
% Call: [ r, ...
%            r0, ...
%            r_squ, ...
%            r0_squ, ...
%            segmWeight, ...
%            isLower, ...
%            isUpper, ...
%            isRadial ] = precompute_anisoSpatDistr( Catalog, poly, M_c, spaceUnit )
%
% INPUTS:
%
% - Catalog:        table                   historic event set. Relevant columns in this function:
%                                           - xx: event coordinate x
%                                           - yy: event coordinate y
%                                           - mm: event magnitude reduced by threshold M_c
%                                           - strike: event strike direction
%                                           - flag: determines type of event: >= 0 for target time
% - poly:           numeric array (2xP)     (centralized) polygon coordinates (x | y)
% - M_c:             scalar                  lower magnitude threshold
% - spaceUnit:      string                  indicates the chosen space unit (e.g. km, degrees, ...)
%
% OUTPUTS:
%
% - r:              cell vector (numerics)  event-to-polygon distances for polygon grid points
% - r0:             cell vector (numerics)  event-to-polygon distances for intermediate polygon grid
%                                           points
% - r_squ:          cell vector (numerics)  squares of r
% - r0_squ:         cell vector (numerics)  squares of r0
% - segmWeight:     cell vector (numerics)  weight of the respective radial segment to entire circle
% - isLower:        cell vector (booleans)  booleans indicating if r_squ values are lower boundary
% - isUpper:        cell vector (booleans)  booleans indicating if r_squ values are upper boundary
% - isRadial:       cell vector (booleans)  booleans indicating if segment is radial approximation


    typeKernel  = Catalog.typeKernel;
    % Indices of events with anisotropic kernel
    idxAniso = find( strcmp(typeKernel, 'aniso') );

    %% Initializations
    % cell arrays
%     SpatData = initialize_tables4precomputations( SpatData, length(Catalog.x), 'aniso' ); 
  
    % Check dimension of polygon
    if ~( size(poly,1)==2 )
        error('Array ''poly'' has not the required line dimension 2! Potentially transposed in original data...')
    end
    
    %% Loop over all events
    for iEvent = idxAniso'
              
%         if ismember(iEvent, [686])
%             makePlots = 0; 
%         else
%             makePlots = 0;
%         end
                
        %% Categorize polygon edges regarding their orientation to event rupture line
        [ polyRotated, ...
           polyStart, ...
           polyEnd, ...
           polyEdgeCategory, ...
           locRotated, ...
           rupLength, ...
           rupXleft, ...
           rupXright, ...
           rupY, ...
           rupFlag ] = categorize_polyEdges( Catalog, poly, iEvent, makePlots );
        
        %% Computation of anisotropic segmentation
        % Boolean, which polygon edges are anisotropic
        isAniso     = polyEdgeCategory==1 | polyEdgeCategory==-1;
        % Computation of distances, segment factors and start-end-markers
        [ aniso_r, ...
          aniso_r0, ...
          ~, ...
          ~, ...
          aniso_segmFactor, ...
          aniso_isStartP, ...
          aniso_isEndP ]   = compute_anisotropicGrid( polyStart(:,isAniso), ...
                                                       polyEnd(:,isAniso), ...
                                                       polyEdgeCategory(isAniso), ...
                                                       rupFlag, ...
                                                       rupLength, ...
                                                       rupXleft, ...
                                                       rupXright, ...
                                                       rupY, ...
                                                       iEvent, ...
                                                       spaceUnit, ...
                                                       makeChecks, ...
                                                       makePlots );
        % Optional: Apply spatial extent                                           
        [ aniso_r, aniso_r_squ, aniso_r0, aniso_r0_squ, ...
          aniso_segmFactor, aniso_isStartP, aniso_isEndP ] ...
            = apply_spatialExtent2SpatData( Catalog.spatRestr(iEvent), ...
                                            aniso_r, aniso_r0, ...
                                            aniso_segmFactor, aniso_isStartP, aniso_isEndP );
            
        % Store event-to-polygon distances, segment factors and start-end booleans
        SpatData.Aniso_r{iEvent}              = aniso_r;
        SpatData.Aniso_r0{iEvent}             = aniso_r0;
        SpatData.Aniso_r_squ{iEvent}          = aniso_r_squ;
        SpatData.Aniso_r0_squ{iEvent}         = aniso_r0_squ;
        SpatData.Aniso_segmFactor{iEvent}     = aniso_segmFactor;
        SpatData.Aniso_isStartP{iEvent}       = aniso_isStartP;
        SpatData.Aniso_isEndP{iEvent}         = aniso_isEndP;                                                           
                                                                   
                                                                           
        %% Computation of isotropic left-side segmentation
        % Boolean, which polygon edges are isotropic left-side
        isIsoLeft = polyEdgeCategory==2;
        % Computation of distances, segment factors and start-end-markers
        [ isoLeft_r, ...
          isoLeft_r0, ...
          ~, ...
          ~, ...
          isoLeft_segmFactor, ...
          isoLeft_isStartP, ...
          isoLeft_isEndP ] = compute_isotropicGrid( polyStart(:,isIsoLeft)', ...
                                                    polyEnd(:,isIsoLeft)', ...
                                                    iEvent, ...
                                                    rupXleft, ...
                                                    rupY, ...
                                                    rupFlag(1), ...
                                                    spaceUnit, ...
                                                    'isotropic left', ...
                                                    makeChecks, ...
                                                    makePlots );
        % Optional: Apply spatial extent                                           
        [ isoLeft_r, isoLeft_r_squ, isoLeft_r0, isoLeft_r0_squ, ...
          isoLeft_segmFactor, isoLeft_isStartP, isoLeft_isEndP ] ...
            = apply_spatialExtent2SpatData( Catalog.spatRestr(iEvent), ...
                                            isoLeft_r, isoLeft_r0, ...
                                            isoLeft_segmFactor, isoLeft_isStartP, isoLeft_isEndP );
        
        %% Computation of isotropic right-side segmentation
        % Boolean, which polygon edges are isotropic right-side
        isIsoRight = polyEdgeCategory==3;
        % Computation of distances, segment factors and start-end-markers
        [ isoRight_r, ...
          isoRight_r0, ...
          ~, ...
          ~, ...
          isoRight_segmFactor, ...
          isoRight_isStartP, ...
          isoRight_isEndP ] = compute_isotropicGrid( polyStart(:,isIsoRight)', ...
                                                     polyEnd(:,isIsoRight)', ...
                                                     iEvent, ...
                                                     rupXright, ...
                                                     rupY, ...
                                                     rupFlag(2), ...
                                                     spaceUnit, ...
                                                     'isotropic right', ...
                                                     makeChecks, ...
                                                     makePlots );
        % Optional: Apply spatial extent                                           
        [ isoRight_r, isoRight_r_squ, isoRight_r0, isoRight_r0_squ, ...
          isoRight_segmFactor, isoRight_isStartP, isoRight_isEndP ] ...
            = apply_spatialExtent2SpatData( Catalog.spatRestr(iEvent), ...
                                            isoRight_r, isoRight_r0, ...
                                            isoRight_segmFactor, isoRight_isStartP, isoRight_isEndP );
        
        %% Combine isotropic left- and right-side data in struct SpatData
        SpatData.Iso_r{iEvent}          = [ isoLeft_r;          isoRight_r ];
        SpatData.Iso_r0{iEvent}         = [ isoLeft_r0;         isoRight_r0 ];
        SpatData.Iso_r_squ{iEvent}      = [ isoLeft_r_squ;      isoRight_r_squ ];
        SpatData.Iso_r0_squ{iEvent}     = [ isoLeft_r0_squ;     isoRight_r0_squ ];
        SpatData.Iso_segmFactor{iEvent} = [ isoLeft_segmFactor; isoRight_segmFactor ];
        SpatData.Iso_isStartP{iEvent}   = [ isoLeft_isStartP;   isoRight_isStartP ];
        SpatData.Iso_isEndP{iEvent}     = [ isoLeft_isEndP;     isoRight_isEndP ];
        
        % Change type of kernel if event is completely inside or completely outside of polygon
        if length(aniso_r)==1 && length(isoLeft_r)==1 && length(isoRight_r)==1
            typeKernel{iEvent}      = 'full';
        end

    end      
                          
end
