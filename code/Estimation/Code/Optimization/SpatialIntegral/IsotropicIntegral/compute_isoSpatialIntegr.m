function [ F, ...
           dF_D, ...
           dF_q ] = compute_isoSpatialIntegr( Catalog, ...
                                              SpatData, ...
                                              isIso, ...
                                              fSpatK_inn, ...
                                              D, q, ...
                                              inclGradients )
       
    [ normaliz, ...
      normalizSqu, ...
      normaliz_D, ...
      normaliz_q ] = compute_normalization4spatIntegr( Catalog, ...
                                                       isIso, ...
                                                       fSpatK_inn, ...
                                                       q );  
  
%     spatDistrWidth      = D*exp(gamma*(Catalog.mag(isIso)-M_c));
%     isWiderThanMinWidth = spatDistrWidth > SpatKernel.minKernelWidth;

    %% Isotropic spatial integral
    r_squ_iso           = SpatData.Iso_r_squ( isIso );
    r0_squ_iso          = SpatData.Iso_r0_squ( isIso );
    segmFactor_iso      = SpatData.Iso_segmFactor( isIso );
    isStartP_iso        = SpatData.Iso_isStartP( isIso );
    isEndP_iso          = SpatData.Iso_isEndP( isIso );
    % Extract columns of Catalog
    mag                 = Catalog.mag( isIso );
    
    nEvents             = sum(isIso);
    [ F, dF_D, dF_q ]   = initialize_spatIntegrOutputVectors( Catalog(isIso,:), 'default' );

    % Loop over all events
    for iEv = 1:nEvents
        % Extract event-specific data from cell arrays (as called multiple times)
        iSegmFactor         = segmFactor_iso{iEv};
        iIsStartP           = isStartP_iso{iEv};
        iIsEndP             = isEndP_iso{iEv};

        % Evaluate inner spatial function (to the 1-q) at event-to-polygon distances 
        f_inn_r             = fSpatK_inn(-1, r_squ_iso{iEv}, mag(iEv), 0);
        f_inn_r0            = fSpatK_inn(-1, r0_squ_iso{iEv}, mag(iEv), 0);
        f_inn_r_to1minusQ   = f_inn_r.^(1-q);
        f_inn_r0_to1minusQ  = f_inn_r0.^(1-q);

        % Compute spatial integral by summing up weighted contributions of all segments
        F(iEv)  = compute_integrPerEvent( iSegmFactor, ...
                                          iIsStartP, ...
                                          iIsEndP, ...
                                          (1-f_inn_r_to1minusQ) ./ normaliz(iEv), ...
                                          (1-f_inn_r0_to1minusQ) ./ normaliz(iEv) );

        if inclGradients
            
            [ dF_D(iEv), ...
              dF_q(iEv) ] = compute_isoGradientsIntegr( iSegmFactor, ...
                                                        iIsStartP, ...
                                                        iIsEndP, ...
                                                        D, q, ...
                                                        normaliz(iEv), ...
                                                        normalizSqu(iEv), ...
                                                        normaliz_D(iEv), ...
                                                        normaliz_q(iEv), ...
                                                        f_inn_r, ...
                                                        f_inn_r0, ...
                                                        f_inn_r_to1minusQ, ...
                                                        f_inn_r0_to1minusQ );

        end
        
    end
    
end
