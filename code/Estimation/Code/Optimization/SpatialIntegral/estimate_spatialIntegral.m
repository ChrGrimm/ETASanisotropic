function [ F, ...
            dF_D, ...
            dF_gamma, ...
            dF_q, ...
            anisoPeaks ] = estimate_spatialIntegral( inclGradients, ...
                                                      Catalog, ...
                                                      Inputs, ...
                                                      spatParamETAS, ...
                                                      ModelFuncs, ...
                                                      SpatData )
   
    %% Initialize output data
    spaceModel  = Inputs.ModelSettings.spaceModel;
    Mc          = Inputs.TargetSettings.Mc;
    [ F, dF_D, dF_gamma, dF_q ] = initialize_spatIntegrOutputVectors( Catalog, spaceModel );
    anisoPeaks                  = -1; % dummy
    
    if ~strcmp(spaceModel, 'none')
        %% Detailed spatial integral estimation
        % Extract categories of spatial kernels
        isFull  = strcmp(Catalog.typeKernel, 'full');
        isIso   = strcmp(Catalog.typeKernel, 'iso');
        isAniso = strcmp(Catalog.typeKernel, 'aniso');
        
        % Initialize output variables
        [ F, dF_D, dF_gamma, dF_q ]   = initialize_spatIntegrOutputVectors( Catalog, spaceModel );

        % Extract spatial parameters
        D           = spatParamETAS(1);
        q           = spatParamETAS(3);  

        % Events that can be approximated by infinite integral
        % (spatial extent is either fully or not at all contained in polygon)
        [ F(isFull), ...
          dF_D(isFull), ...
          dF_q(isFull) ] = compute_infiniteSpatialIntegr( Catalog, ...
                                                          isFull, ...
                                                          spatParamETAS );
                                                              
        % Events with isotropic spatial integral computation
        [ F(isIso), ...
          dF_D(isIso), ...
          dF_q(isIso) ] = compute_isoSpatialIntegr( Catalog, ...
                                                    SpatData, ...
                                                    isIso, ...
                                                    ModelFuncs.fSpatK_inn, ...
                                                    D, q, ...
                                                    inclGradients );
        
        % Events with anisotropic spatial integral computation
        try
        [ F(isAniso), ...
          dF_D(isAniso), ...
          dF_q(isAniso), ...
          anisoPeaks ] = compute_anisoSpatialIntegr( inclGradients, ...
                                                      Catalog, ...
                                                      isAniso, ...
                                                      spatParamETAS, ...
                                                      ModelFuncs.fSpatK_inn, ...
                                                      ModelFuncs.fSpatK_factor, ...
                                                      SpatData );
        catch
            test=-1;
        end
                                                  
        % Compute gradiants by gamma as (m-Mc)/D times gradients by D
        if inclGradients
            dF_gamma = dF_D .* (Catalog.mag-Mc) * D;    
        end
        
    end
    
end
%% Old code pieces
        % Extract event-specific magnitude and distribution width
%         magn                = Catalog.mag;
%         wi                  = Catalog.wi;  
%         spatDistrWidth      = D*exp(gamma*(Catalog.mag-Mc));
%         isWiderThanMinWidth = spatDistrWidth > SpatKernel.minKernelWidth; 

